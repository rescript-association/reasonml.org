# Undefined

<Intro>

Provide utilities around `Js.undefined`.

</Intro>

## t

```re sig
type t('a) = Js.undefined('a);
```

Local alias for 'a Js.undefined.

## return

```re sig
let return: 'a => t('a);
```

Constructs a value of `Js.undefined('a)` containing a value of `'a`.

## test

```re sig
let test: t('a) => bool;
```

Returns `true` if the given value is empty (undefined), `false` otherwise.

## testAny

```re sig
let testAny: 'a => bool;
```

Since 1.6.1 Returns `true` if the given value is empty (undefined).

## empty

```re sig
let empty: t('a);
```

The empty value, `undefined`.

## getUnsafe

```re sig
let getUnsafe: t('a) => 'a;
```

## getExn

```re sig
let getExn: t('a) => 'a;
```

## bind

```re sig
let bind: (t('a), (. 'a) => 'b) => t('b);
```

Maps the contained value using the given function.
If `Js.undefined('a)` contains a value, that value is unwrapped, mapped to a `'b` using the given function `a' => 'b`, then wrapped back up and returned as `Js.undefined('b)`.

```re example
let maybeGreetWorld = (maybeGreeting: Js.undefined(string)) =>
  Js.Undefined.bind(maybeGreeting, [@bs] greeting => greeting ++ " world!");
```

## iter

```re sig
let iter: (t('a), (. 'a) => unit) => unit;
```

Iterates over the contained value with the given function.
If `Js.undefined('a)` contains a value, that value is unwrapped and applied to the given function.

```re example
let maybeSay = (maybeMessage: Js.undefined(string)) =>
  Js.Undefined.iter(maybeMessage, [@bs] message => Js.log(message));
```

## fromOption

```re sig
let fromOption: option('a) => t('a);
```

Maps `option('a)` to `Js.undefined('a)`.
`Some(a)` => `a`
`None` => `empty`

## from_opt

```re sig
let from_opt: option('a) => t('a);
```

## toOption

```re sig
let toOption: t('a) => option('a);
```

Maps `Js.undefined('a)` to `option('a)`
`a` => `Some(a)`
`empty` => `None`

## to_opt

```re sig
let to_opt: t('a) => option('a);
```
