# List

<Intro>

Provide utilities for list.

</Intro>

## t

```re sig
type t('a) = list('a);
```

## length

```re sig
let length: t('a) => int;
```

## cons

```re sig
let cons: ('a, t('a)) => t('a);
```

## isEmpty

```re sig
let isEmpty: t('a) => bool;
```

## hd

```re sig
let hd: t('a) => option('a);
```

## tl

```re sig
let tl: t('a) => option(t('a));
```

## nth

```re sig
let nth: (t('a), int) => option('a);
```

## revAppend

```re sig
let revAppend: (t('a), t('a)) => t('a);
```

## rev

```re sig
let rev: t('a) => t('a);
```

## mapRev

```re sig
let mapRev: ((. 'a) => 'b, t('a)) => t('b);
```

## map

```re sig
let map: ((. 'a) => 'b, t('a)) => t('b);
```

## iter

```re sig
let iter: ((. 'a) => unit, t('a)) => unit;
```

## iteri

```re sig
let iteri: ((. int, 'a) => unit, t('a)) => unit;
```

## foldLeft

```re sig
let foldLeft: ((. 'a, 'b) => 'a, 'a, list('b)) => 'a;
```

Application order is left to right, tail-recurisve.

## foldRight

```re sig
let foldRight: ((. 'a, 'b) => 'b, list('a), 'b) => 'b;
```

Application order is right to left, tail-recursive.

## flatten

```re sig
let flatten: t(t('a)) => t('a);
```

## filter

```re sig
let filter: ((. 'a) => bool, t('a)) => t('a);
```

## filterMap

```re sig
let filterMap: ((. 'a) => option('b), t('a)) => t('b);
```

## countBy

```re sig
let countBy: ((. 'a) => bool, list('a)) => int;
```

## init

```re sig
let init: (int, (. int) => 'a) => t('a);
```

## toVector

```re sig
let toVector: t('a) => Js_vector.t('a);
```

## equal

```re sig
let equal: ((. 'a, 'a) => bool, list('a), list('a)) => bool;
```
