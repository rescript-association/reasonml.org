import { make as Layout } from "../../layouts/BeltDocsLayout.bs.js";
export default Layout;

# MutableMapInt

## key

```
type key = int;
```

## t

```
type t('a);
```

## make

```
let make: unit => t('a);
```

## clear

```
let clear: t('a) => unit;
```

## isEmpty

```
let isEmpty: t('a) => bool;
```

## has

```
let has: (t('a), key) => bool;
```

## cmpU

```
let cmpU: (t('a), t('a), [@bs] (('a, 'a) => int)) => int;
```

## cmp

```
let cmp: (t('a), t('a), ('a, 'a) => int) => int;
```

`cmp(m1, m2, cmp)` First compare by size, if size is the same, compare by key, value pair.

## eqU

```
let eqU: (t('a), t('a), [@bs] (('a, 'a) => bool)) => bool;
```

## eq

```
let eq: (t('a), t('a), ('a, 'a) => bool) => bool;
```

`eq(m1, m2, cmp)`

## forEachU

```
let forEachU: (t('a), [@bs] ((key, 'a) => unit)) => unit;
```

## forEach

```
let forEach: (t('a), (key, 'a) => unit) => unit;
```

`forEach(m, f)` applies `f` to all bindings in map `m`. `f` receives the key as first argument, and the associated value as second argument. The application order of `f` is in increasing order.

## reduceU

```
let reduceU: (t('a), 'b, [@bs] (('b, key, 'a) => 'b)) => 'b;
```

## reduce

```
let reduce: (t('a), 'b, ('b, key, 'a) => 'b) => 'b;
```

`reduce(m, a, f), computes`(f(kN, dN) ... (f(k1, d1, a))...)`, where`k1 ... kN`are the keys of all bindings in`m`(in increasing order), and`d1 ... dN` are the associated data.

## everyU

```
let everyU: (t('a), [@bs] ((key, 'a) => bool)) => bool;
```

## every

```
let every: (t('a), (key, 'a) => bool) => bool;
```

`every(m, p)` checks if all the bindings of the map satisfy the predicate `p`. The application order of `p` is unspecified.

## someU

```
let someU: (t('a), [@bs] ((key, 'a) => bool)) => bool;
```

## some

```
let some: (t('a), (key, 'a) => bool) => bool;
```

`some(m, p)` checks if at least one binding of the map satisfy the predicate `p`. The application order of `p` is unspecified.

## size

```
let size: t('a) => int;
```

## toList

```
let toList: t('a) => list((key, 'a));
```

In increasing order

## toArray

```
let toArray: t('a) => array((key, 'a));
```

## fromArray

```
let fromArray: array((key, 'a)) => t('a);
```

## keysToArray

```
let keysToArray: t('a) => array(key);
```

## valuesToArray

```
let valuesToArray: t('a) => array('a);
```

## minKey

```
let minKey: t('a) => option(key);
```

## minKeyUndefined

```
let minKeyUndefined: t('a) => Js.undefined(key);
```

## maxKey

```
let maxKey: t('a) => option(key);
```

## maxKeyUndefined

```
let maxKeyUndefined: t('a) => Js.undefined(key);
```

## minimum

```
let minimum: t('a) => option((key, 'a));
```

## minUndefined

```
let minUndefined: t('a) => Js.undefined((key, 'a));
```

## maximum

```
let maximum: t('a) => option((key, 'a));
```

## maxUndefined

```
let maxUndefined: t('a) => Js.undefined((key, 'a));
```

## get

```
let get: (t('a), key) => option('a);
```

## getUndefined

```
let getUndefined: (t('a), key) => Js.undefined('a);
```

## getWithDefault

```
let getWithDefault: (t('a), key, 'a) => 'a;
```

## getExn

```
let getExn: (t('a), key) => 'a;
```

## checkInvariantInternal

```
let checkInvariantInternal: t('a) => unit;
```

Raise when invariant is not held.

## remove

```
let remove: (t('a), key) => unit;
```

`remove(m, x)` do the in-place modification.

## removeMany

```
let removeMany: (t('a), array(key)) => unit;
```

## set

```
let set: (t('a), key, 'a) => unit;
```

`set(m, x, y)` do the in-place modification, return `m` for chaining. If `x` was already bound in `m`, its previous binding disappears.

## updateU

```
let updateU: (t('a), key, [@bs] (option('a) => option('a))) => unit;
```

## update

```
let update: (t('a), key, option('a) => option('a)) => unit;
```

## mapU

```
let mapU: (t('a), [@bs] ('a => 'b)) => t('b);
```

## map

```
let map: (t('a), 'a => 'b) => t('b);
```

`map(m, f)` returns a map with same domain as `m`, where the associated value a of all bindings of `m` has been replaced by the result of the application of `f` to `a`. The bindings are passed to `f` in increasing order with respect to the ordering over the type of the keys.

## mapWithKeyU

```
let mapWithKeyU: (t('a), [@bs] ((key, 'a) => 'b)) => t('b);
```

## mapWithKey

```
let mapWithKey: (t('a), (key, 'a) => 'b) => t('b);
```
