import { make as Layout } from "../../layouts/BeltDocsLayout.bs.js";
export default Layout;

# Map

The top level provides generic immutable map operations.

It also has three specialized inner modules `Belt.Map.Int`, `Belt.Map.String` and `Belt.Map.Dict`.

## t

```re sig
type t('key, 'value, 'identity);
```

## id

```re sig
type id('key, 'id) = Belt_Id.comparable('key, 'id);
```

## isEmpty

```re sig
let isEmpty: t('a, 'b, 'c) => bool;
```

## has

```re sig
let has: (t('k, 'v, 'id), 'k) => bool;
```

## cmpU

```re sig
let cmpU: (t('k, 'v, 'id), t('k, 'v, 'id), [@bs] (('v, 'v) => int)) => int;
```

## cmp

```re sig
let cmp: (t('k, 'v, 'id), t('k, 'v, 'id), ('v, 'v) => int) => int;
```

## eq

```re sig
let eqU: (t('k, 'v, 'id), t('k, 'v, 'id), [@bs] (('v, 'v) => bool)) => bool;
```

## eq

```re sig
let eq: (t('k, 'v, 'id), t('k, 'v, 'id), ('v, 'v) => bool) => bool;
```

## findFirstByU

```re sig
let findFirstByU: (t('k, 'v, 'id), [@bs] (('k, 'v) => bool)) => option(('k, 'v));
```

## findFirstBy

```re sig
let findFirstBy: (t('k, 'v, 'id), ('k, 'v) => bool) => option(('k, 'v));
```

## forEachU

```re sig
let forEachU: (t('k, 'v, 'id), [@bs] (('k, 'v) => unit)) => unit;
```

## forEach

```re sig
let forEach: (t('k, 'v, 'id), ('k, 'v) => unit) => unit;
```

## reduceU

```re sig
let reduceU: (t('k, 'v, 'id), 'acc, [@bs] (('acc, 'k, 'v) => 'acc)) => 'acc;
```

## reduce

```re sig
let reduce: (t('k, 'v, 'id), 'acc, ('acc, 'k, 'v) => 'acc) => 'acc;
```

## everyU

```re sig
let everyU: (t('k, 'v, 'id), [@bs] (('k, 'v) => bool)) => bool;
```

## every

```re sig
let every: (t('k, 'v, 'id), ('k, 'v) => bool) => bool;
```

## someU

```re sig
let someU: (t('k, 'v, 'id), [@bs] (('k, 'v) => bool)) => bool;
```

## some

```re sig
let some: (t('k, 'v, 'id), ('k, 'v) => bool) => bool;
```

## size

```re sig
let size: t('k, 'v, 'id) => int;
```

## toArray

```re sig
let toArray: t('k, 'v, 'id) => array(('k, 'v));
```

## toList

```re sig
let toList: t('k, 'v, 'id) => list(('k, 'v));
```

## fromArray

```re sig
let fromArray: (array(('k, 'v)), ~id: id('k, 'id)) => t('k, 'v, 'id);
```

## keysToArray

```re sig
let keysToArray: t('k, 'v, 'id) => array('k);
```

## valuesToArray

```re sig
let valuesToArray: t('k, 'v, 'id) => array('v);
```

## minKey

```re sig
let minKey: t('k, 'a, 'b) => option('k);
```

## minKeyUndefined

```re sig
let minKeyUndefined: t('k, 'a, 'b) => Js.undefined('k);
```

## maxKey

```re sig
let maxKey: t('k, 'a, 'b) => option('k);
```

## maxKeyUndefined

```re sig
let maxKeyUndefined: t('k, 'a, 'b) => Js.undefined('k);
```

## minimum

```re sig
let minimum: t('k, 'v, 'a) => option(('k, 'v));
```

## minUndefined

```re sig
let minUndefined: t('k, 'v, 'a) => Js.undefined(('k, 'v));
```

## maximum

```re sig
let maximum: t('k, 'v, 'a) => option(('k, 'v));
```

## maxUndefined

```re sig
let maxUndefined: t('k, 'v, 'a) => Js.undefined(('k, 'v));
```

## get

```re sig
let get: (t('k, 'v, 'id), 'k) => option('v);
```

## getUndefined

```re sig
let getUndefined: (t('k, 'v, 'id), 'k) => Js.undefined('v);
```

## getWithDefault

```re sig
let getWithDefault: (t('k, 'v, 'id), 'k, 'v) => 'v;
```

## getExn

```re sig
let getExn: (t('k, 'v, 'id), 'k) => 'v;
```

## remove

```re sig
let remove: (t('k, 'v, 'id), 'k) => t('k, 'v, 'id);
```

## removeMany

```re sig
let removeMany: (t('k, 'v, 'id), array('k)) => t('k, 'v, 'id);
```

## set

```re sig
let set: (t('k, 'v, 'id), 'k, 'v) => t('k, 'v, 'id);
```

## updateU

```re sig
let updateU: (t('k, 'v, 'id), 'k, [@bs] (option('v) => option('v))) => t('k, 'v, 'id);
```

## update

```re sig
let update: (t('k, 'v, 'id), 'k, option('v) => option('v)) => t('k, 'v, 'id);
```

## mergeMany

```re sig
let mergeMany: (t('k, 'v, 'id), array(('k, 'v))) => t('k, 'v, 'id);
```

## mergeU

```re sig
let mergeU:
(t('k, 'v, 'id), t('k, 'v2, 'id), [@bs] (('k, option('v), option('v2)) => option('v3))) =>
t('k, 'v3, 'id);
```

## merge

```re sig
let merge:
(t('k, 'v, 'id), t('k, 'v2, 'id), ('k, option('v), option('v2)) => option('v3)) =>
t('k, 'v3, 'id);
```

## keepU

```re sig
let keepU: (t('k, 'v, 'id), [@bs] (('k, 'v) => bool)) => t('k, 'v, 'id);
```

## keep

```re sig
let keep: (t('k, 'v, 'id), ('k, 'v) => bool) => t('k, 'v, 'id);
```

## partitionU

```re sig
let partitionU: (t('k, 'v, 'id), [@bs] (('k, 'v) => bool)) => (t('k, 'v, 'id), t('k, 'v, 'id));
```

## partition

```re sig
let partition: (t('k, 'v, 'id), ('k, 'v) => bool) => (t('k, 'v, 'id), t('k, 'v, 'id));
```

## split

```re sig
let split: (t('k, 'v, 'id), 'k) => ((t('k, 'v, 'id), t('k, 'v, 'id)), option('v));
```

## mapU

```re sig
let mapU: (t('k, 'v, 'id), [@bs] ('v => 'v2)) => t('k, 'v2, 'id);
```

## map

```re sig
let map: (t('k, 'v, 'id), 'v => 'v2) => t('k, 'v2, 'id);
```

## mapWithKeyU

```re sig
let mapWithKeyU: (t('k, 'v, 'id), [@bs] (('k, 'v) => 'v2)) => t('k, 'v2, 'id);
```

## mapWithKey

```re sig
let mapWithKey: (t('k, 'v, 'id), ('k, 'v) => 'v2) => t('k, 'v2, 'id);
```

## getData

```re sig
let getData: t('k, 'v, 'id) => Belt_MapDict.t('k, 'v, 'id);
```

## getId

```re sig
let getId: t('k, 'v, 'id) => id('k, 'id);
```

## packIdData

```re sig
let packIdData: (~id: id('k, 'id), ~data: Belt_MapDict.t('k, 'v, 'id)) => t('k, 'v, 'id);
```
