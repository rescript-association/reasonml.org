# MutableQueue

<Intro>

An FIFO(first in first out) queue data structure.

</Intro>

## t

```
type t('a);
```

The type of queues containing elements of `type('a)`.

## make

```
let make: unit => t('a);
```

Returns a new queue, initially empty.

## clear

```
let clear: t('a) => unit;
```

Discard all elements from the queue.

## isEmpty

```
let isEmpty: t('a) => bool;
```

Returns `true` if the given queue is empty, `false` otherwise.

## fromArray

```
let fromArray: array('a) => t('a);
```

`fromArray` a is equivalent to `Array.forEach(a, add(q, a));`

## add

```
let add: (t('a), 'a) => unit;
```

`add(q, x)` adds the element `x` at the end of the queue `q`.

## peek

```
let peek: t('a) => option('a);
```

`peekOpt(q)` returns the first element in queue `q`, without removing it from the queue.

## peekUndefined

```
let peekUndefined: t('a) => Js.undefined('a);
```

`peekUndefined(q)` returns `undefined` if not found.

## peekExn

```
let peekExn: t('a) => 'a;
```

raise an exception if `q` is empty

## pop

```
let pop: t('a) => option('a);
```

`pop(q)` removes and returns the first element in queue `q`.

## popUndefined

```
let popUndefined: t('a) => Js.undefined('a);
```

`popUndefined(q)` removes and returns the first element in queue `q`. it will return `undefined` if it is already empty.

## popExn

```
let popExn: t('a) => 'a;
```

`popExn(q)` raise an exception if q is empty.

## copy

```
let copy: t('a) => t('a);
```

`copy(q)` returns a fresh queue.

## size

```
let size: t('a) => int;
```

Returns the number of elements in a queue.

## mapU

```
let mapU: (t('a), [@bs] ('a => 'b)) => t('b);
```

## map

```
let map: (t('a), 'a => 'b) => t('b);
```

## forEachU

```
let forEachU: (t('a), [@bs] ('a => unit)) => unit;
```

## forEach

```
let forEach: (t('a), 'a => unit) => unit;
```

`forEach(q, f) applies`f`in turn to all elements of`q`, from the least recently entered to the most recently entered. The queue itself is unchanged.

## reduceU

```
let reduceU: (t('a), 'b, [@bs] (('b, 'a) => 'b)) => 'b;
```

## reduce

```
let reduce: (t('a), 'b, ('b, 'a) => 'b) => 'b;
```

`reduce(q, accu, f)` is equivalent to `List.reduce(l, accu, f)`, where `l` is the list of `q`'s elements. The queue remains unchanged.

## transfer

```
let transfer: (t('a), t('a)) => unit;
```

`transfer(q1, q2)` adds all of `q1`'s elements at the end of the queue `q2`, then clears `q1`. It is equivalent to the sequence `forEach((x) => add(x, q2), q1);`; clear `q1`, but runs in constant time.

## toArray

```
let toArray: t('a) => array('a);
```

First added will be in the beginning of the array.
